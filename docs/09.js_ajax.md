# HTTP와 Ajax

## 학습 목표
- Ajax를 통한 비동기 통신 구현
- HTTP 프로토콜 이해
- API 테스트 도구 활용
- XMLHttpRequest, Fetch API, axios 사용법 습득
- 쿠키를 이용한 상태 관리

## 목차
- [1. HTTP 프로토콜](#1-HTTP-프로토콜)
  + [1.1 주요 특징](#11-주요-특징)
  + [1.2 동작 방식](#12-동작-방식)
  + [1.3 Request 메시지 구조](#13-request-메시지-구조)
  + [1.4 Response 메시지 구조](#14-response-메시지-구조)
  + [1.5 장점](#15-장점)
  + [1.6 참고](#16-참고)
  + [1.7 HTTP의 특징](#17-http의-특징)
  + [1.8 HTTP 주요 메서드](#18-http-주요-메서드)
- [2. API 테스트](#2-api-테스트)
  + [2.1 API 서버](#21-api-서버)
  + [2.2 Postman](#22-postman)
  + [2.3 Todo List API 테스트](#23-todo-list-api-테스트)
  + [2.4 Open Market API 테스트](#24-open-market-api-테스트)
- [3. Ajax란?](#3-ajax란)
- [4. XMLHttpRequest 객체](#4-xmlhttprequest-객체)
  + [4.1 XMLHttpRequest 사용](#41-xmlhttprequest-사용)
- [5. Fetch API](#5-fetch-api)
  + [5.1 사용 예시](#51-사용-예시)
  + [5.2 fetch(resource, options?)](#52-fetchresource-options)
- [6. axios 라이브러리](#6-axios-라이브러리)
  + [6.1 사용 예시](#61-사용-예시)
  + [6.2 설치](#62-설치)
  + [6.3 요청 API](#63-요청-api)
  + [6.4 Axios 인스턴스](#64-axios-인스턴스)
  + [6.5 인터셉터](#65-인터셉터)
- [7. 쿠키를 이용한 클라이언트 상태 관리](#7-쿠키를-이용한-클라이언트-상태-관리)
  + [7.1 쿠키 (Cookie)](#71-쿠키-cookie)
  + [7.2 쿠키 접근 및 조작](#72-쿠키-접근-및-조작)
  + [7.3 쿠키 옵션](#73-쿠키-옵션)
  + [7.4 Ajax와 클라이언트 상태 저장](#74-ajax와-클라이언트-상태-저장)
  + [7.5 클라이언트 저장 방식 비교](#75-클라이언트-저장-방식-비교)

---

## 1. HTTP 프로토콜
HTTP(HyperText Transfer Protocol)는 웹 브라우저와 웹 서버 간 텍스트 기반으로 데이터를 송수신하기 위한 프로토콜

### 1.1 주요 특징
- TCP 기반 프로토콜
- 클라이언트와 서버가 연결을 수립한 후 메시지를 교환
- 데이터를 패킷 단위로 전송하며, 수신 측에서 데이터를 검증한 뒤 응답을 보냄
- 데이터 누락 시 재전송 요청을 처리하여 신뢰성이 높음
- 주로 HTTP, FTP, SMTP 등 신뢰성이 중요한 통신에서 사용됨

### 1.2 동작 방식
1. 클라이언트의 요청 (Request)
   - 클라이언트(주로 웹 브라우저)가 HTTP 요청 메시지를 서버로 전송
   - 요청에는 필요한 자원(URL)이나 작업(GET, POST 등 요청 메서드 포함)이 포함됨

2. 서버의 응답 (Response)
   - 서버는 요청을 분석하여 필요한 작업을 수행
     + 파일 읽기, 데이터베이스 조회, 외부 시스템 연동 등
   - 작업 결과를 바탕으로 응답 메시지를 생성하여 클라이언트로 전송

3. 웹 브라우저의 처리
   - 클라이언트는 서버 응답 데이터를 받아 파싱한 후 화면에 출력
   - 서버의 응답을 받은 후 클라이언트와 서버 간 연결이 해제됨 (HTTP/1.x의 경우 기본적으로 비연결형(Connectionless) 프로토콜)

### 1.3 Request 메시지 구조

- GET 방식 예시
```
GET /ch09/ex09-01.html HTTP/1.1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate, br, zstd
Accept-Language: ko,en-US;q=0.9,en;q=0.8
Cache-Control: no-cache
Connection: keep-alive
Host: 127.0.0.1:8080
if-modified-since: Sun, 26 Oct 2025 09:13:15
If-None-Match: W/"191-19a1fcb18fe"
Referer: http://127.0.0.1:8080/ch09/ex09-01.html
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36
...
```

- POST 방식 예시
```
POST /todo/todolist HTTP/1.1
Content-Type: application/json
User-Agent: PostmanRuntime/7.49.1
Accept: */*
Postman-Token: ef1fd75c-f843-4257-8043-c722886fbb2a
Host: fesp-api.koyeb.app
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Content-Length: 98
 
{
"title": "TodoList - API 테스트",
"content": "API 테스트 잘되는지 확인"
}
```

#### 요청 라인 (Request Line)
```
GET /todolist HTTP/1.1
POST /todolist HTTP/1.1
PATCH /todolist/5 HTTP/1.1
```

- 요청 메서드(Method): GET, POST, PUT, PATCH, DELETE 등
- 요청 대상(Request Target): URL 경로
- HTTP 버전(HTTP Version): HTTP/1.1 또는 HTTP/2 등

#### 요청 헤더 (Request Headers)
```
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate, br, zstd
Accept-Language: ko,en-US;q=0.9,en;q=0.8
Cache-Control: no-cache
Connection: keep-alive
Host: 127.0.0.1:8080
if-modified-since: Sun, 26 Oct 2025 09:13:15
If-None-Match: W/"191-19a1fcb18fe"
Referer: http://127.0.0.1:8080/ch09/ex09-01.html
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36
```

- `Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8`
  + 클라이언트가 선호하는 응답 콘텐츠 타입과 품질 지수(q값: 0~1, 생략시 1, 1이 가장 높은 선호도)
- `Accept-Encoding: gzip, deflate, br, zstd`
  + 클라이언트가 지원하는 압축 방식
- `Accept-Language: ko,en-US;q=0.9,en;q=0.8`
  + 클라이언트가 선호하는 언어와 우선순위
- `Cache-Control: no-cache`
  + 캐시 동작 제어
  + no-cache: 캐시된 응답을 사용하기 전 서버에 검증 요청 (항상 재검증, 304 Not Modified이면 캐시 사용, 변경되었으면 새 데이터 다운로드)
  + no-store: 응답을 캐시에 저장하지 않음
  + max-age=3600: 캐시 유효 시간(초 단위)
- `Connection: keep-alive`
  + 연결 유지 여부 (keep-alive: 연결 유지, close: 연결 종료)
- `Host: 127.0.0.1:8080`
  + 요청을 보내는 서버의 도메인 주소와 포트
- `if-modified-since: Sun, 26 Oct 2025 09:13:15`
  + 캐시된 리소스의 Last-Modified 시간을 전송, 서버가 변경되지 않았으면 304 Not Modified 응답
- `If-None-Match: W/"191-19a1fcb18fe"`
  + 캐시된 리소스의 ETag 값을 전송, 서버가 변경되지 않았으면 304 Not Modified 응답
- `Referer: http://127.0.0.1:8080/ch09/ex09-01.htm`
  + 요청이 시작된 이전 페이지의 URL (철자 주의: Referer는 실제로는 Referrer지만 명세상 오타로 Referer로 표기)
- `User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36`
  + 클라이언트의 브라우저 및 OS 정보

#### 요청 바디 (Request Body)
```json
{
  "title": "TodoList - API 테스트",
  "content": "API 테스트 잘되는지 확인"
}
```

- GET 요청: 바디 없음 (데이터는 쿼리 파라미터로 URL에 포함하여 전송)
- POST, PUT, PATCH, DELETE 요청: JSON, XML, form-data 등 다양한 형식의 데이터 전송 가능

### 1.4 Response 메시지 구조
- 예시
```
HTTP/1.1 200 OK
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sun, 26 Oct 2025 09:13:15 GMT
ETag: W/"191-19a1fcb18fe"
Content-Type: text/html; charset=utf-8
Date: Sun, 26 Oct 2025 09:18:27 GMT
Connection: keep-alive
Keep-Alive: timeout=5
Transfer-Encoding: chunked

<!DOCTYPE html>
<html lang="ko">
...
</html>
```

#### 상태 라인 (Status Line)
```
HTTP/1.1 200 OK
HTTP/1.1 201 Created
HTTP/1.1 404 Not Found
HTTP/1.1 500 Internal Server Error
```
- HTTP 버전(HTTP Version): HTTP/1.1 또는 HTTP/2 등
- 상태 코드(Status Code): 200(성공), 404(찾을 수 없음), 500(서버 에러) 등
- 이유 구문(Reason Phrase): OK, Created, Not Found 등 응답 상태를 간단한 텍스트로 표현

##### 주요 응답 상태 코드

###### 2xx (성공)
- `200 OK`: 요청이 성공적으로 처리됨, 응답 본문에 요청된 리소스가 포함됨
- `201 Created`: 요청이 성공했으며 새로운 리소스가 생성됨 (일반적으로 POST 요청)
- `204 No Content`: 요청은 성공했지만 응답 본문이 없음 (일반적으로 DELETE 요청)

###### 3xx (리디렉션)
- `301 Moved Permanently`: 요청한 리소스가 영구적으로 이동됨, 새 URL은 Location 헤더에 포함
- `302 Found`: 요청한 리소스가 임시로 이동됨
- `304 Not Modified`: 리소스가 변경되지 않아 캐시된 버전을 사용해도 됨

###### 4xx (클라이언트 오류)
- `400 Bad Request`: 잘못된 요청 구문으로 서버가 처리할 수 없음
- `401 Unauthorized`: 인증이 필요함, 로그인 정보가 없거나 만료됨
- `403 Forbidden`: 인증은 됐지만 권한이 없어 거부됨
- `404 Not Found`: 요청한 리소스를 찾을 수 없음
- `405 Method Not Allowed`: 요청한 HTTP 메서드가 허용되지 않음

###### 5xx (서버 오류)
- `500 Internal Server Error`: 서버 내부 오류, 예상치 못한 문제 발생

#### 응답 헤더 (Response Headers)
```
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sun, 26 Oct 2025 09:13:15 GMT
ETag: W/"191-19a1fcb18fe"
Content-Type: text/html; charset=utf-8
Date: Sun, 26 Oct 2025 09:18:27 GMT
Connection: keep-alive
Keep-Alive: timeout=5
Transfer-Encoding: chunked
```

- `Accept-Ranges: bytes`
  + 서버가 `부분 요청(Partial Request)`을 지원함
  + 클라이언트가 `Range: bytes=1000-1999` 형식으로 바이트 단위의 범위 요청 가능
- `Cache-Control: public, max-age=0`
  + 캐시 동작 제어 (public: 브라우저뿐만 아니라 중간 프록시도 캐시 가능, max-age=0: 즉시 만료되므로 항상 재검증 필요)
- `Last-Modified: Sun, 26 Oct 2025 09:13:15 GMT`
  + 리소스가 마지막으로 수정된 시간 (If-Modified-Since와 함께 캐시 검증에 사용)
- `ETag: W/"191-19a1fcb18fe"`
  + 리소스의 버전 식별자 (If-None-Match와 함께 캐시 검증에 사용)
- `Content-Type: text/html; charset=utf-8`
  + 응답 바디의 미디어 타입과 문자 인코딩
- `Date: Sun, 26 Oct 2025 09:18:27 GMT`
  + 응답이 생성된 시간
- `Connection: keep-alive`
  + 연결 유지 여부 (keep-alive: 연결 유지, HTTP/1.1에서는 기본값)
- `Keep-Alive: timeout=5`
  + keep-alive 연결의 최대 유지 시간(초)
- `Transfer-Encoding: chunked`
  + 데이터 전송 인코딩 방식 (chunked: 청크 단위로 분할 전송)

#### 응답 바디 (Response Body)
```html
<!DOCTYPE html>
<html lang="ko">
...
</html>
```

- 성공 응답: 요청한 데이터를 JSON, XML, HTML 등 형식으로 반환
- 에러 응답: 에러 메시지와 함께 상태 정보 반환

### 1.5 장점
- 신뢰성: TCP를 기반으로 하여 데이터 전달의 신뢰성이 높음
- 범용성: 전 세계적으로 가장 널리 사용되는 웹 통신 프로토콜

### 1.6 참고
- HTTP/2와 HTTP/3는 기존 HTTP/1.x의 비효율성을 개선하기 위해 다중화, 헤더 압축, UDP 기반 전송 등의 기술을 도입

### 1.7 HTTP의 특징

#### 비연결성(Connectionless)
- 클라이언트가 요청을 보내고 서버가 응답하면 상호 연결을 해제함
- 서버는 클라이언트가 누구인지 신경 쓰지 않고 요청 정보만 분석해 적절한 응답을 만드는 데만 집중함
- 서버 구현이 단순해져 웹 발전에 큰 역할을 함

#### 무상태(Stateless)
- 서버는 클라이언트의 요청 정보만 가지고 응답을 생성하며, 클라이언트의 상태를 기억하지 않음
- 요청한 사용자가 누구인지, 이전에 어떤 작업을 요청했는지를 관리하지 않음
  + 웹이 발전하면서 클라이언트 정보를 저장할 필요가 생겼고, 이를 위해 Cookie, Session 등의 저장 방식이 도입됨

### 1.8 HTTP 주요 메서드

#### GET
- 서버로부터 자원을 가져올 때 사용
  + 할일 목록 조회
  + 할일 상세 조회
  + 회원 정보 조회

#### POST
- 서버로 데이터를 보낼 때 사용
  + 할일 등록
  + 회원 등록

#### PUT
- 서버 데이터 한 건의 전체 항목 수정 시 사용
  + 특정 할일의 모든 항목 수정
  + 특정 회원의 회원 정보 전체 수정

#### PATCH
- 서버 데이터 한 건의 일부 항목 수정 시 사용
  + 특정 할일의 완료 여부 수정
  + 특정 회원의 비밀번호 수정

#### DELETE
- 서버의 데이터 한 건을 삭제할 때 사용
  + 할일 삭제
  + 회원 삭제

## 2. API 테스트

### 2.1 API 서버
- API(Application Programming Interface) 서버란?
  + 응용 프로그램 간 데이터를 주고받을 수 있도록 중개하는 인터페이스를 제공하는 서버
  + 클라이언트(웹 브라우저, 모바일 앱 등)와 백엔드 서버 간의 통신을 위한 게이트웨이 역할
  + 프로그램 간 상호작용을 가능하게 하는 서버 측 인터페이스

#### REST API
- REST(Representational State Transfer)
  + 웹의 장점을 최대한 활용할 수 있도록 고안된 아키텍처 스타일(원칙)
  + 2000년 로이 필딩(Roy Fielding)이 논문에서 제안한 설계 원칙
  + "상태 전달"을 의미: 리소스의 상태(표현)를 클라이언트와 서버 간에 전달하는 방식
  + 프로토콜이나 표준이 아닌 아키텍처 설계 가이드라인
- REST API
  + REST 원칙을 따라 구현된 웹 API
  + HTTP 프로토콜을 기반으로 REST 아키텍처 스타일을 적용한 API
  + 클라이언트-서버 간 데이터 통신을 위한 인터페이스 제공
  + 웹, 모바일, 데스크톱 등 다양한 클라이언트에서 동일한 API 사용 가능
- 주요 특징
  + 표준 HTTP 프로토콜 사용: HTTP의 기존 표준을 그대로 활용
  + 자원(Resource)을 URI로 표현: 각 리소스는 고유한 URI를 가짐
  + HTTP 메서드로 작업 지시: GET(조회), POST(생성), PUT/PATCH(수정), DELETE(삭제)
  + Stateless(무상태): 서버는 클라이언트의 상태를 저장하지 않음, 각 요청은 독립적

##### 예시
- GET `/todo/todolist`: 할일 목록 조회
- POST `/todo/todolist`: 새 할일 등록
- PATCH `/todo/todolist/5`: 할일 정보 수정 (완료 여부, 내용 등)
- DELETE `/todo/todolist/5`: 할일 삭제

### 2.2 Postman
- 브라우저 대신 HTTP 요청을 만들어서 서버에 전송하고 응답을 확인할 수 있는 도구
- API를 테스트하고 개발하기 위한 도구
- https://www.postman.com/downloads 접속 후 다운로드
- 본인의 OS에 맞는 버전 다운로드 후 기본 설정으로 설치

### 2.3 Todo List API 테스트
#### Workspace 생성
- Workspaces > Create Workspace
  + Blank Workspace > Next
  + Name: `FEBC15` > Create

#### 환경 변수 추가
- Environments > + 버튼(Create new environment) 
- "New Environment" -> `Todo List`로 수정

##### API 서버 URL 추가
- Variable: url
- Value: `https://fesp-api.koyeb.app/todo`

#### Collection 추가
- Collections > + 버튼(Create new collection) > Blank collection
  + "New Collection" -> `Todo API`로 수정

#### API Server 환경 변수 지정
- 우측 상단의 "No Environment" 클릭 후 Todo List 선택

#### 할일 목록 조회
- Collections > Todo API 컬렉션 위에 마우스 올린 후 `+`(Add Request) 클릭
  + "New Request" -> `할일 목록 조회`로 수정
  + "Enter URL or paste text" 항목에 `{{url}}/todolist` 입력 후 Send
  + 응답 결과 확인

#### 할일 등록
- Collections > Todo API 컬렉션 위에 마우스 올린 후 `+` 클릭
  + Todo API/`할일 등록`
  + "GET" -> `POST`로 수정
  + `{{url}}/todolist`
  + Body > raw > "Text"로 되어 있을 경우 "JSON"으로 변경. 데이터 입력 후 Send
  ```json
  {
    "title": "TodoList - API 테스트",
    "content": "API 테스트 잘되는지 확인"
  }
  ```

#### 할일 상세 조회
- Todo API/`할일 상세 조회`
- `GET`, `{{url}}/todolist/5`

#### 할일 완료
- Todo API/`할일 완료`
- `PATCH`, `{{url}}/todolist/5`
- Body > raw > 데이터 입력 후 Send
```json
{
  "done": true
}
```

#### 할일 내용 수정
- Todo API/`할일 내용 수정`
- `PATCH`, `{{url}}/todolist/5`
- Body > raw > 데이터 입력 후 Send
```json
{
  "title": "TodoList - 수정",
  "content": "API 수정 잘되는지 확인"
}
```

#### 할일 삭제
- Todo API/`할일 삭제`
- `DELETE`, `{{url}}/todolist/5`

### 2.4 Open Market API 테스트

#### 환경 변수 추가
- Environments > + 버튼(Create new environment) 
- "New Environment" -> `Open Market`으로 수정

##### API 서버 URL 추가
- Variable: `url`
- Value: `https://fesp-api.koyeb.app/market`

##### client-id 추가
- Variable: `client-id`
- Value: `openmarket`

#### Collection 추가
- Collections > + 버튼(Create new collection) > Blank collection
  + "New Collection" -> `Open Market API`로 수정

#### API Server 환경 변수 지정
- 우측 상단의 "No Environment" 또는 "Todo List" 클릭 후 `Open Market` 선택

#### 상품 목록 조회
- Collections > Open Market API 컬렉션 위에 마우스 올린 후 `...`(View more actions) 클릭 후 `Add folder` 선택
  + "New Forder" -> `상품`으로 수정
- Collections > Open Market API > 상품 위에 마우스 올린 후 `+`(Add request) 클릭
  + "New Request" -> `상품 목록 조회`로 수정
  + "Enter URL or paste text" 항목에 `{{url}}/products` 입력 후 Send
  + 응답 결과 확인
  ```json
  {
    "ok": 0,
    "message": "client-id 헤더가 없습니다."
  }
  ```
- client-id 헤더 추가
  + Headers 탭 선택
    + Key: `client-id`
    + Value: `{{client-id}}`

#### 상품 상세 조회
- Collections > Open Market API 컬렉션 위에 마우스 올린 후 `+` 클릭
  + Open Market API/상품/`상품 상세 조회`
  + `GET`, `{{url}}/products/4`
  + 응답 결과 확인
  ```json
  {
    "ok": 0,
    "message": "client-id 헤더가 없습니다."
  }
  ```
- 컬렉션내의 모든 요청에 client-id 헤더 추가
  + Collections > Open Market API 선택
  + Scripts > Pre-req 선택 후 추가
  ```js
  pm.request.headers.add({
    key: "client-id",
    value: "{{client-id}}"
  });
  ```

#### 회원 정보 조회
- Collections > Open Market API 컬렉션 위에 마우스 올린 후 `...`(View more actions) 클릭 후 `Add folder` 선택
  + "New Forder" -> `회원`으로 수정
- Collections > Open Market API > 회원 위에 마우스 올린 후 `+`(Add request) 클릭
  + "New Request" -> `회원 정보 조회`로 수정
  + "Enter URL or paste text" 항목에 `{{url}}/users/4` 입력 후 Send

#### 회원 정보 수정
- Open Market API/회원/`회원 정보 수정`
- `PATCH`, `{{url}}/users/4`
- Body > raw > 데이터 입력 후 Send
```json
{
  "name": "하루"
}
```
- 응답 결과 확인
```json
{
    "ok": 0,
    "message": "authorization 헤더가 없습니다.",
    "errorName": "EmptyAuthorization"
}
```

#### 로그인
- Open Market API/회원/`로그인`
- `POST`, `{{url}}/users/login`
- Body > raw > 데이터 입력 후 Send
```json
{
  "email": "u1@market.com",
  "password": "11111111"
}
```

##### 로그인 응답 결과로 받은 토큰을 환경 변수에 세팅
- Collections > Open Market API > 회원 > 로그인 > Scripts > Post-response
  ```js
  if (pm.response.code === 200) {
    const jsonData = pm.response.json();
    const accessToken = jsonData.item.token.accessToken;
    const refreshToken = jsonData.item.token.refreshToken;
    pm.environment.set("accessToken", accessToken);
    pm.environment.set("refreshToken", refreshToken);
  }
  ```
- Send
- Environments > Open Market 환경 변수에 accessToken과 refreshToken 추가 되었는지 확인

##### 회원 정보 수정 요청 헤더에 토큰 인증 정보 추가
- Collections > Open Market API > 회원 > 회원 정보 수정 > Authorization
  + Auth Type: Bearer Token
  + Token: `{{accessToken}}`
  + Send
  + 정상 응답 결과 확인

#### 컬렉션내의 모든 요청에 토큰 인증 정보 추가
- Collections > Open Market API > Auth
  + Auth Type: Bearer Token
  + Token: `{{accessToken}}`
  + Ctrl + S 눌러서 저장
  
#### 회원 정보 수정 요청시 인증은 부모(컬렉션)에서 지정한 인증 방식으로 변경
- Collections > Open Market API > 회원 > 회원 정보 수정 > Authorization
  + Auth Type: Inherit auth from parent

## 3. Ajax란?
- Ajax(Asynchronous JavaScript and XML)는 클라이언트와 서버 간 비동기 통신 기법
- 자바스크립트로 HTTP 요청을 보내고 응답을 받아 처리하는 방식
  + 과거에는 XML을 주로 사용했지만, 현재는 JSON이 더 선호됨
- 페이지 이동이나 새로고침 없이 서버에 요청을 보내고 DOM API를 이용해 화면을 갱신
- SPA(Single Page Application)를 구현하기 위한 핵심 기법

## 4. XMLHttpRequest 객체
- 서버에 HTTP 요청을 만들고 전송할 수 있는 자바스크립트 객체
- 웹 초창기부터 사용되어 구버전 브라우저에서도 동작
- 서버의 응답 메시지는 콜백 방식의 함수를 등록해서 사용

### 4.1 XMLHttpRequest 사용

#### 생성
- `const xhr = new XMLHttpRequest();`

#### 주요 메서드
- `open(method, url, async)`
  + 요청의 초기화에 사용하는 메서드
  + `method`: HTTP method. GET, POST, PUT, PATCH, DELETE 등
  + `url`: 요청하는 자원의 URL
  + `async`
    - `true`: 기본값, 비동기 방식으로 요청
    - `false`: 동기 방식으로 요청
- `send(data)`
  + 서버에 요청을 전송하는 메서드
  + `data`: POST, PUT, PATCH등 요청 바디에 전달할 데이터 지정. `name1=value1&name2=value2` 형태

#### 주요 속성
- `onload`: 응답이 도착하면 발생하는 이벤트 등록
- `status`: 서버로부터 받은 응답 상태코드. 200, 404, 500 등
- `responseText`: 서버로부터 받은 응답 바디 문자열

#### 사용 예시
```ts
interface Cat {
  id: string;
  url: string;
  width: number;
  height: number;
}

const url = 'https://api.thecatapi.com/v1/images/search';

function getImages(): void {
  // 1. XMLHttpRequest 생성   
  const xhr = new XMLHttpRequest();
  // 2. 요청준비(open())
  xhr.open('get', url, true); // false일 경우 네트워크 요청이 완료될 때까지 블로킹(동기) 방식으로 동작하기 때문에 권장하지 않음
  // 4. 응답 데이터 처리
  xhr.addEventListener('load', function(){
    const result = this.responseText;
    const data: Cat[] = JSON.parse(result);
    console.log(data);
  });
  // 3. 요청(send())
  xhr.send();
};
```

#### 💻 [09-01 랜덤 고양이 이미지 가져오기 - XMLHttpRequest 사용](../workspace-ins/ch09/ex09-01.html)

## 5. Fetch API
- ES6에 추가된 HTTP 클라이언트 
- 콜백 기반인 XMLHttpRequest와 달리 Promise 기반으로 설계됨
- XMLHttpRequest를 대체할 수 있는 표준 API
- XMLHttpRequest보다 나은 선택이지만 다음과 같은 단점이 있음
  + 응답 객체에서 본문을 바로 꺼낼 수 없으며, JSON이나 다른 데이터 타입으로 파싱이 필요
  + 네트워크 에러를 제외한 HTTP 응답 에러(4xx, 5xx)에 대해 오류가 발생하지 않으므로 별도로 체크 필요
  + 이러한 이유로 axios와 같은 라이브러리에 비해 사용이 다소 불편
  
### 5.1 사용 예시
```ts
interface Cat {
  id: string;
  url: string;
  width: number;
  height: number;
}

const url = 'https://api.thecatapi.com/v1/images/search';

async function getImages() {
  try {
    const response = await fetch(url);
    if (response.ok) {
      const data: Cat[] = await response.json(); // json 파싱이 필요
      console.log(data);
    } else {
      console.error(response); // 4xx, 5xx HTTP 응답 오류에 대한 처리
    }
  } catch (err) {
    console.error(err); // 네트워크 에러에 대한 처리
  }
}
```

#### 💻 [09-02 랜덤 고양이 이미지 가져오기 - Fetch API 사용](../workspace-ins/ch09/ex09-02.html)

### 5.2 fetch(resource, options?)
- 지정한 resource로 HTTP 요청을 보냄
- 참고: https://developer.mozilla.org/ko/docs/Web/API/Window/fetch#credentials

#### resource
- 문자열, URL 객체, Request 객체
- 문자열 지정
  ```ts
  const options = {
    method: 'GET',
  };
  const response = await fetch('https://api.thecatapi.com/v1/images/search', options);
  ```

- URL 객체 지정
  ```ts
  const url = new URL('https://api.thecatapi.com/v1/images/search');
  url.searchParams.set('limit', '10'); // 10개
  url.searchParams.set('breed_ids', 'pers'); // 페르시안 고양이
  const options = {
    method: 'GET',
  };
  const response = await fetch(url, options);
  ```

- Request 객체 지정
  ```ts
  const options = {
    method: 'GET',
  };
  const request = new Request('https://api.thecatapi.com/v1/images/search', options);
  const response = await fetch(request);
  ```

#### options
- method: 요청을 생성할때 사용되는 HTTP 메서드(GET, POST, PATCH, DELETE 등), 기본 GET
- headers: 사용자 지정 헤더
- body: 요청 바디로 전송될 데이터
- mode: CORS 정책
  + cors: 기본값. CORS 요청 허용. 서버 응답에 `Access-Control-Allow-Origin` 헤더가 추가되어야 함
  + no-cors: CORS 요청은 서버에 전송되지만 응답 본문을 텍스트나 json으로 읽을 수 없음(이미지를 바이너리로 읽는 것은 가능)
  + same-origin: CORS 요청을 허용하지 않음. 다른 서버로 요청을 보내면 요청이 실패함
- credentials: 자격 증명을(쿠키, HTTP 인증, TLS 클라이언트 인증서) 사용하여 사이트 간 액세스 제어 요청을 어떻게 해야 하는지 여부 지정
  + omit: 브라우저가 요청에서 자격증명을 제외하고 Set-Cookie 헤더처럼 응답에 포함된 자격증명도 무시
  + same-origin: 기본값. 동일 출처 요청에 대해서는 자격증명을 보내거나 받음
  + include: CORS 요청에 대해서도 자격증명을 보내거나 받음
- cache: HTTP 캐시와 어떻게 상호작용할지를 지정
  + default | no-store | reload | no-cache | force-cache | only-if-cached
  + 자세한 내용: https://developer.mozilla.org/ko/docs/Web/API/Request/cache
- redirect: 서버의 redirect 응답에 대한 처리
  + follow: 기본값. 자동으로 redirect 됨
  + error: redirect 발생 시 오류와 함께 요청 중단
  + manual: redirect 되지 않고 응답 그대로 Response 객체를 반환함. 개발자가 이후의 작업을 직접 구현
- referrer
- referrerPolicy
- integrity
- keepalive
- signal
- priority

## 6. axios 라이브러리
- Node.js와 브라우저에서 사용 가능한 Promise 기반 HTTP 클라이언트
- XMLHttpRequest 객체를 기반으로 동작하여 Fetch API보다 호환성 좋음
- 요청 및 응답을 가로채는 인터셉터 기능 제공
- JSON 형식의 응답 데이터를 자동으로 객체로 파싱
- timeout 설정 가능

### 6.1 사용 예시
```ts
interface Cat {
  id: string;
  url: string;
  width: number;
  height: number;
}

const url = 'https://api.thecatapi.com/v1/images/search';

async function getImages() {
  try{
    const response = await axios.get<Cat[]>(url);
    const data: Cat[] = response.data; // json 파싱이 필요 없음
    console.log(data);
  } catch(err) {
    // 네트워크 에러나 4xx, 5xx HTTP 응답 에러 일괄 처리
    console.error(err);
  }
}

```

### 6.2 설치

```sh
# workspace 폴더로 이동
cd workspace
# - node.js의 라이브러리 관리를 위한 `pagkage.json` 먼저 생성
npm init -y
# axios 라이브러리 설치
npm i axios
```

### 6.3 요청 API
#### `axios(url, config?)`, `axios(config)`, `axios.request(config)`
- 지정한 url로 HTTP 요청을 보냄(기본 GET 방식)

- 사용 사례
  ```ts
  const response = await axios.get<Cat[]>('https://api.thecatapi.com/v1/images/search');
  console.log(response.data);
  ```

  ```ts
  // 할일 목록 조회
  const { data } = await axios('https://fesp-api.koyeb.app/todo/todolist');
  console.log(data);
  ```

  ```ts
  // 할일 등록
  const { data } = await axios('https://fesp-api.koyeb.app/todo/todolist', {
    method: 'post',
    data: {
      title: '할일 1',
      content: '내용 1'
    }
  }); 
  ```

  ```ts
  // 할일 수정
  const { data } = await axios({
    url: 'https://fesp-api.koyeb.app/todo/todolist/1',
    method: 'patch',
    data: {
      title: '할일 1 수정',
      content: '내용 1 수정'
    }
  }); 
  ```

  ```ts
  // 할일 삭제
  const { data } = await axios.request({
    url: 'https://fesp-api.koyeb.app/todo/todolist/1',
    method: 'delete'
  });
  ```

#### config 객체의 주요 속성
```ts
{
  // `url`이 절대값이 아닌 경우 `baseURL`이 url 앞에 붙음
  baseURL: 'https://fesp-api.koyeb.app/todo',
  
  // 요청에 사용될 서버 URL
  url: '/todolist',

  // 요청을 생성할때 사용되는 메서드
  method: 'get', // 기본값 get

  // 사용자 지정 헤더
  headers: {'Authrization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c'},

  // `params`는 요청과 함께 전송되는 URL 파라미터(pathname? 뒤에 추가되는 name=value 쌍의 문자열)
  // 반드시 일반 객체나 URLSearchParams 객체여야 함
  // 참고: null이나 undefined는 URL에 추가되지 않음
  params: {
    page: 3,
    limit: 10
  },

  // 요청 바디로 전송될 데이터
  // 'PUT', 'POST', 'PATCH', 'DELETE' 메서드에서만 적용 가능
  // 다음 타입 중 하나여야 함
  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams
  // - 브라우저 전용: FormData, File, Blob
  data: {
    title: '10시간 푹자기',
    content: '이번 주말에 도전해야지'
  },

  // 응답이 `timeout(밀리초)`보다 오래 걸리면 요청이 중단되고 timeout 에러 발생
  timeout: 1000, // 기본값은 `0` (타임아웃 없음)

  // 자격 증명을(쿠키, HTTP 인증, TLS 클라이언트 인증서) 사용하여 사이트 간 액세스 제어 요청을 해야 하는지 여부 지정
  // 다른 도메인으로 CORS 요청시 쿠키(Cookie, Set-Cookie)가 기본으로 포함되지 않으므로 이를 사용하기 위해서는 true로 설정해야 함
  // 서버에서도 응답헤더 Access-Control-Allow-Credentials: true 설정이 필요
  withCredentials: false, // 기본값
}
```

#### HTTP 메서드별로 제공되는 함수
- `axios.get(url, config?)`
  ```ts
  const { data } = await axios.get('/todolist');
  ```

- `axios.post(url, data, config?)`
  ```ts
  try{
    await axios.post('/todolist', {
      title: '할일 1',
      content: '내용 1'
    });
    alert('할일이 추가 되었습니다.');
  }catch(err){
    console.error(err);
    alert('할일 추가에 실패했습니다.');
  }
  ```

- `axios.patch(url, data, config?)`
  ```ts
  try{
    await axios.patch(`/todolist/1`, {
      content: '수정된 내용'
    });
    alert('할일을 수정했습니다.');
  }catch(err){
    console.error(err);
    alert('할일 수정에 실패했습니다.');
  }
  ```

- `axios.delete(url, config?)`
  ```ts
  try{
    await axios.delete(`/todolist/1`);
    alert('할일이 삭제 되었습니다.');
  }catch(err){
    console.error(err);
    alert('할일 삭제에 실패했습니다.');
  }
  ```

- `axios.put(url, data, config?)`
- `axios.head(url, config?)`
- `axios.options(url, config?)`

### 6.4 Axios 인스턴스
- 지정한 config 정보로 새로운 Axios 인스턴스 생성

- `axios.create(config?)`

#### 사용 예시
```ts
const instance = axios.create({
  baseURL: 'https://fesp-api.koyeb.app/todo', // 기본 URL
  timeout: 3000, // 지정한 시간이 지나도록 응답이 완료되지 않으면 timeout 에러 발생
  headers: {
    'content-type': 'application/json', // request의 데이터 타입
    accept: 'application/json'  // 선호하는 응답 데이터 타입
  },
});

instance.get('/todolist', {
  params: {
    page: 3,
    limit: 5
  },
});
```

### 6.5 인터셉터
- axios로 서버에 HTTP 요청을 보내기 직전이나 응답이 도착해서 리턴되기 전에 요청과 응답을 가로채서 추가적인 작업 수행 가능

#### 사용 사례
```ts
// 요청 인터셉터 추가하기
axios.interceptors.request.use((config) => {
  // 요청이 전달되기 전에 필요한 공통 작업 수행(조건부 요청 헤더 추가, 로깅, 요청 데이터 변환, 조건부 요청 취소 등의 동적인 설정에 사용)

  return config;
}, (error) => {
  // 요청 인터셉터에서 에러가 발생할 경우 호출
  return Promise.reject(error);
});

// 응답 인터셉터 추가하기
axios.interceptors.response.use((response) => {
  // 2xx 범위에 있는 상태 코드가 응답되면 이 함수가 호출됨
  // 응답 데이터를 이용해서 필요한 공통 작업 수행(응답 로깅, 응답 데이터 변환 등)

  return response;
}, (error) => {
  // 2xx 외의 범위에 있는 상태 코드가 응답되면 이 함수가 호출됨
  // 공통 에러 처리

  return Promise.reject(error);
});
```

---

## 7. 쿠키를 이용한 클라이언트 상태 관리
- 참고: https://ko.javascript.info/cookie

- 웹 애플리케이션에서 사용자 정보, 설정 등을 클라이언트에 저장하는 방법
- 서버와 클라이언트 간 상태 정보를 동기화하고 관리
- 다양한 저장 방식을 통해 데이터 지속성 확보

### 7.1 쿠키 (Cookie)
#### 쿠키의 특징
- 웹 브라우저에 저장되는 `name=value` 형식의 작은 텍스트 파일
- 서버와 클라이언트 간 상태 정보를 유지하기 위해 사용
- HTTP 요청 시 자동으로 서버에 전송됨
- 도메인별로 분리되어 저장
  + `https://naver.com`, `https://daum.net`에서 전송한 쿠키는 각 도메인별로 별도로 관리
- 만료 시간 설정 가능
- 보안 옵션 설정 가능 (HttpOnly, Secure, SameSite)
- 크기 제한(브라우저마다 다름): 쿠키당 약 4KB, 도메인당 50여개

### 7.2 쿠키 접근 및 조작
- `document.cookie`: 현재 페이지의 모든 쿠키를 읽거나 설정
- 읽기: 쿠키 문자열을 파싱하여 개별 쿠키 값 추출
- 쓰기: 쿠키 문자열 형태로 설정

#### 쿠키 설정 동작
- `document.cookie`는 한 번에 하나의 쿠키만 설정할 수 있음
- 다른 이름의 쿠키: 누적되어 추가됨
- 같은 이름의 쿠키 (동일한 path, domain 조건): 기존 쿠키가 덮어씌워짐 (업데이트)
- 여러 개의 쿠키를 설정하려면 각각 별도의 `document.cookie` 문을 사용해야 함

```js
// 쿠키 설정
// 다른 이름의 쿠키들은 누적되어 추가됨
document.cookie = "username=haru; expires=Thu, 18 Dec 2026 12:00:00 UTC; path=/";
document.cookie = "theme=dark; expires=Thu, 18 Dec 2026 12:00:00 UTC; path=/";
document.cookie = "language=ko; expires=Thu, 18 Dec 2026 12:00:00 UTC; path=/";

// 쿠키 읽기
// document.cookie는 모든 쿠키를 세미콜론(뒤에 공백 포함)으로 구분된 하나의 문자열로 반환
// expires, path 등의 옵션은 포함되지 않고 name=value 형식만 반환됨
console.log(document.cookie); // "username=haru; theme=dark; language=ko"

// 같은 이름의 쿠키를 설정하면 기존 쿠키가 덮어씌워짐 (업데이트)
document.cookie = "username=namu; expires=Thu, 18 Dec 2026 12:00:00 UTC; path=/";
console.log(document.cookie); // "username=namu; theme=dark; language=ko"

// 쿠키 파싱 함수
function getCookie(name) {
  const value = `; ${document.cookie}`;
  const parts = value.split(`; ${name}=`);
  if (parts.length === 2) return parts.pop().split(';').shift();
}

// 쿠키 설정 함수
function setCookie(name, value, days) {
  const expires = new Date();
  expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
  document.cookie = `${name}=${value}; expires=${expires.toUTCString()}; path=/`;
}
```

### 7.3 쿠키 옵션
- `expires`: 쿠키 만료 시간 (Date 객체)
  + 형식: 절대적인 날짜/시간
  + 예시: `expires=Thu, 18 Dec 2026 12:00:00 UTC`
  + 특징: 특정 날짜와 시간에 만료됨
- `max-age`: 쿠키 만료 시간 (초 단위)
  + 형식: 상대적인 시간 (초 단위)
  + 예시: `max-age=3600` (1시간 후 만료)
  + 특징: 쿠키가 설정된 시점부터 계산된 시간 후 만료됨
  + `expires`와 `max-age` 둘 다 지정하면 `max-age`가 우선됨
  + 둘 다 없으면 세션 쿠키 (브라우저 종료 시 삭제)
- `path`: 쿠키가 유효한 경로 (기본값: 현재 경로)
  + 예시: `path=/posts`
- `domain`: 쿠키가 유효한 도메인 (기본값: 현재 도메인)
  + 예시: `domain=https://myapp.com`
- `secure`: HTTPS에서만 전송
- `samesite`: CSRF 공격 방지 (Strict, Lax(기본), None)

```js
// 보안 옵션이 포함된 쿠키 설정
document.cookie = "sessionId=abc123; secure; samesite=strict; httponly";
```

### 7.4 Ajax와 클라이언트 상태 저장
- Ajax 요청 시 쿠키가 자동으로 서버에 전송됨
- 서버에서 응답헤더에 `Set-Cookie`로 설정한 쿠키는 브라우저에 자동 저장
- 인증 토큰, 세션 ID 등을 쿠키로 관리

```js
// Ajax 요청 시 쿠키 자동 전송
fetch('/api/user/profile', {
  // 생략시 기본값: credentials: 'same-origin'
  // 'same-origin': 같은 도메인 요청에만 쿠키가 자동으로 포함
  credentials: 'include' // 다른 도메인이라고 해도 요청에 쿠키를 포함하여 전송
})
.then(response => response.json())
.then(data => console.log(data));

// axios에서 쿠키 포함
axios.get('/api/user/profile', {
  // 생략시 기본값: withCredentials: false
  withCredentials: true // 모든 요청에 쿠키를 포함하여 전송
});
```

### 7.5 클라이언트 저장 방식 비교
- 쿠키: 서버와 자동 동기화, 크기 제한 있음(작음), 만료 시간 설정 가능
- localStorage: 클라이언트에만 저장, 크기 제한 있음(큼), 만료 시간은 직접 수동으로 관리
- sessionStorage: 클라이언트에만 저장, 크기 제한 있음(큼), 세션이 만료되면 같이 만료(브라우저 탭 종료시 삭제됨), 탭별로 분리되어 관리

---