# 자바스크립트 함수

## 목표
자바스크립트 함수 학습

## 목차
- [1. 참조 타입(Function, 함수)](#1-참조-타입function-함수)
- [2. 일급 객체(First-class object)](#2-일급-객체first-class-object)
- [3. 함수 생성](#3-함수-생성)
- [4. 호이스팅 (hoisting)](#4-호이스팅-hoisting)
- [5. 매개변수와 인자의 수](#5-매개변수와-인자의-수)
- [6. 암묵적 매개변수](#6-암묵적-매개변수)
- [7. 함수 호출 방법](#7-함수-호출-방법)
- [8. 익명 함수 (Anonymous function)](#8-익명-함수-anonymous-function)
- [9. 콜백 함수 (Callback function)](#9-콜백-함수-callback-function)
- [10. 순수 함수 (Pure Function)](#10-순수-함수-pure-function)
- [11. 고차 함수 (Higher-Order Function)](#11-고차-함수-higher-order-function)
- [12. 고차 함수 사용 예 - 메모이제이션](#12-고차-함수-사용-예---메모이제이션)
- [13. 즉시 실행 함수](#13-즉시-실행-함수)

---

## 1. 참조 타입(Function, 함수)
- 참고: https://ko.javascript.info/function-basics

### 1.1 함수란?
- 함수(Function)는 특정 작업을 수행하는 코드 블록을 하나의 단위로 묶은 것
- 여러 명령어를 하나의 단위로 묶어서 재사용 가능하게 만듦
- 코드의 중복을 줄이고 가독성을 높이며 유지보수를 쉽게 함
- 함수명, 매개변수 목록, 실행구문, 반환값으로 구성됨

#### 함수 정의
```js
function 함수명(매개변수1, 매개변수2, ...) {
  실행할 구문1;
  실행할 구문2;
  ......
  return 반환값; // 선택사항
}
```

#### 함수 사용
- 함수를 정의한 후에는 함수명과 괄호를 사용하여 호출할 수 있음

```js
var result = 함수명(인자값1, 인자값2);
```

### 1.2 함수의 특징과 장점
1. 재사용성: 한 번 정의하면 여러 번 호출 가능하여 코드 중복을 방지
2. 모듈화: 복잡한 프로그램을 작은 단위로 나누어 관리하기 쉬움
3. 캡슐화: 함수 내부의 구현 세부사항을 숨겨 코드의 안정성 향상
4. 가독성: 복잡한 로직을 의미있는 이름으로 표현하여 이해하기 쉬움
5. 유지보수: 함수 내부만 수정하면 모든 호출 부분에 자동 반영
6. 테스트: 개별 함수를 독립적으로 테스트하여 디버깅 용이

---

## 2. 일급 객체(First-class object)

### 2.1 일급 객체란?
- 변수, 배열 엘리먼트, 다른 객체의 프로퍼티에 할당될 수 있다.
- 함수의 인자로 전달될 수 있다.
- 함수의 결과 값으로 반환될 수 있다.
- 리터럴로 생성될 수 있다.
- 동적으로 생성된 프로퍼티를 가질 수 있다.

#### 💻 [02-01 변수, 배열 엘리먼트, 다른 객체의 프로퍼티에 함수 할당](../workspace-ins/ch02/ex02-01.js)
#### 💻 [02-02 함수를 다른 함수의 인자로 전달](../workspace-ins/ch02/ex02-02.js)
#### 💻 [02-03 함수를 다른 함수의 리턴값으로 활용](../workspace-ins/ch02/ex02-03.js)
#### 💻 [02-04 함수도 객체처럼 프로퍼티를 가질 수 있다](../workspace-ins/ch02/ex02-04.js)

### 2.2 자바스크립트의 함수(Function)는 일급 객체이다.
- 함수 == (호출 + 객체)

### 2.3 함수가 일급 객체라서 가능한 일
- 콜백 함수(Callback function)
  + 다른 함수에 인자로 전달되어 어떤 작업의 결과로 호출되는 함수
- 고차 함수(Higher order function)
  + 함수를 인자로 받거나 반환하는 함수
- 클로저(Closure)

---

## 3. 함수 생성

### 3.1 함수를 만드는 방법 1 - 함수 선언문 (Function Declaration)
- 참고: https://ko.javascript.info/function-basics#ref-15

- function 키워드로 시작하는 함수 정의

```js
function add(x, y){
  const result = x + y;
  return result;
}

function(){}
```

#### 함수 구성 요소
- 함수 이름
  + 유효한 식별자이어야 함
  + 생략 가능
- 매개변수 목록
  + 쉼표로 구분된 매개변수 목록과 그 매개변수 목록을 둘러싸고 있는 괄호
  + 매개변수는 생략 가능, 괄호는 필수
- 함수 본문
  + 중괄호로 둘러싸여 있는 자바스크립트 구문
  + 본문은 생략 가능, 중괄호는 필수

#### 💻 [02-05 선언문](../workspace-ins/ch02/ex02-05.js)

### 3.2 함수를 만드는 방법 2 - 함수 표현식 (Function Expression)
- 참고: https://ko.javascript.info/function-expressions

- 함수 정의를 변수에 할당
- 변수명을 함수명처럼 사용

#### 변수에 익명함수를 지정

```js
const add = function(x, y){
  const result = x + y;
  return result;
};

add(10, 20);
```

#### 💻 [02-06 표현식 - 익명함수](../workspace-ins/ch02/ex02-06.js)

#### 변수에 기명함수를 지정
- 함수명을 통한 접근은 해당 함수 내부에서만 사용 가능 (재귀 함수)

```js
const f = function factorial(n){
  if(n==1) return 1;
  return n * factorial(n-1);
};

console.log(f(5));
console.log(factorial(5)); // 에러
```

#### 💻 [02-07 표현식 - 기명함수](../workspace-ins/ch02/ex02-07.js)
#### 💻 [02-08 표현식 - 기명함수 사용(팩토리얼 함수)](../workspace-ins/ch02/ex02-08.js)

### 3.3 함수를 만드는 방법 3 - Function 생성자
- 참고: https://ko.javascript.info/new-function

- 함수를 생성해서 반환

```js
const add = new Function('x', 'y', 'let result = x + y; return result;');
```

#### 💻 [02-09 Function 생성자 함수](../workspace-ins/ch02/ex02-09.js)

### 3.4 함수를 만드는 방법 4 - ES6 화살표 함수 (Arrow Function)
- 참고: https://ko.javascript.info/arrow-functions-basics

- 함수 표현식의 대안으로 간결하게 함수 정의
- 익명 함수로만 정의 가능
- 실행할 코드가 하나만 있다면 함수 본문의 중괄호 생략 가능
- 함수 본문의 중괄호가 생략될 경우 함수의 코드가 자동으로 리턴값으로 사용됨
- 매개 변수가 하나만 있다면 매개변수의 괄호 생략 가능

#### 화살표 함수 예시

```js
// 기존 함수(표현식)
const add = function(x, y) {
  return x + y;
};

// 화살표 함수
const add = (x, y) => {
  return x + y;
}

// 화살표 함수 축약
const add = (x, y) => x + y;
```

```js
// 기존 함수(표현식)
const add10 = function(x) {
  return x + 10;
};

// 화살표 함수
const add10 = (x) => {
  return x + 10;
}

// 화살표 함수 축약
const add10 = x => x + 10;
```

#### 💻 [02-10 화살표 함수](../workspace-ins/ch02/ex02-10.js)
#### 💻 [02-10-02 화살표 함수 - 배열 메서드에서 사용](../workspace-ins/ch02/ex02-10-02.js)

---

## 4. 호이스팅 (hoisting)
- 참고: https://ko.javascript.info/var

### 4.1 함수 호이스팅
- 선언문 형태로 정의한 함수의 유효 범위가 코드의 맨 처음부터 시작하게 되는 자바스크립트의 동작 방식
- 특정 블럭의 코드가 자바스크립트 엔진에 의해 실행 되기 전에 호이스팅 단계를 거치는데 이때 선언문 형태의 함수가 생성 되므로 함수 선언 코드보다 먼저 호출하는 코드를 작성하는게 가능
- 함수 선언문만 호이스팅되며, 함수 표현식은 호이스팅되지 않음

#### 함수 선언문의 호이스팅
```js
console.log(add(2, 3));

function add(x, y) {
  return x + y;
}

console.log(add(3, 4));
```

- 호이스팅 단계에 의해 실행되는 순서
```js
function add(x, y) {
  return x + y;
}

console.log(add(2, 3)); // 5
console.log(add(3, 4)); // 7
```

#### 💻 [02-11 선언문 방식의 함수 호이스팅](../workspace-ins/ch02/ex02-11.js)
#### 💻 [02-11-02 선언문 방식의 함수 호이스팅(실제 호출되는 순서)](../workspace-ins/ch02/ex02-11-02.js)


### 4.2 변수 호이스팅
- 호이스팅 단계에서 `var`로 선언한 변수의 경우 선언만 되고 그 값은 `undefined`로 초기화 됨
- `let`, `const`로 선언한 변수의 경우 호이스팅 단계에서 선언은 되지만 초기화가 되지 않기 때문에 선언 전에 접근하면 에러 발생 (undefined 값도 할당되지 않은 상태)

#### 변수 호이스팅
```js
console.log(a);
console.log(b);

var a = 10;
let b = 20;
```

- 호이스팅 단계에 의해 실행되는 순서
```js
var a; // undefined
let b; // b는 undefined로 초기화 되지 않음

console.log(a); // undefined
console.log(b); // ReferenceError: Cannot access 'b' before initialization

a = 10; // 호이스팅 단계에서 undefined로 초기화 됨
b = 20; // 호이스팅 단계에서 선언만 되고 초기화가 안됨
```

#### 함수 표현식의 호이스팅
```js
console.log(add(2, 3));

var add = function(x, y) {
  return x + y;
};
```

- 호이스팅 단계에 의해 실행되는 순서
```js
var add; // undefined

console.log(add(2, 3)); // TypeError: add is not a function

add = function(x, y) {
  return x + y;
};
```

#### 💻 [02-12 변수 호이스팅](../workspace-ins/ch02/ex02-12.js)
#### 💻 [02-12-02 표현식 방식의 함수 호이스팅 - var](../workspace-ins/ch02/ex02-12-02.js)
#### 💻 [02-12-03 표현식 방식의 함수 호이스팅(실제 호출되는 순서) - var](../workspace-ins/ch02/ex02-12-03.js)

### 4.3 TDZ(Temporal Dead Zone)
- `let`, `const`로 선언한 변수가 호이스팅 단계에서 선언된 이후 실제 초기화가 이루어지기 전까지의 구간
- 변수를 초기화 하기 이전에 변수에 접근할 수 없는 일시적인 영역으로, 무분별한 변수 사용을 막고 예측 가능한 코드를 만들기 위한 장치

```js
console.log(add(2, 3));

const add = function(x, y) {
  return x + y;
}
```

- 호이스팅 단계
```js
const add; // undefined로 초기화 되지 않음
// TDZ ~ 

console.log(add(2, 3)); // ReferenceError: Cannot access 'add' before initialization

// ~ TDZ
add = function(x, y) {
  return x + y;
}
```

#### 💻 [02-12-04 표현식 방식의 함수 호이스팅 - let, const](../workspace-ins/ch02/ex02-12-04.js)
#### 💻 [02-12-05 표현식 방식의 함수 호이스팅(실제 호출되는 순서) - let, const](../workspace-ins/ch02/ex02-12-05.js)

---

## 5. 매개변수와 인자의 수
- 참고: https://ko.javascript.info/function-basics#ref-18

### 5.1 매개변수와 인자의 수
- 함수에 정의한 매개변수와 함수 호출에 사용되는 인자의 수가 달라도 에러가 발생하지는 않음

### 5.2 매개변수의 수 > 인자의 수
- 부족한 인자에 대한 매개변수에는 `undefined`가 지정됨

```js
function add(x, y, z) {
  console.log(z); // undefined
  return x + y;
}
console.log(add(3, 4)); // 7
```

### 5.3 매개변수의 수 < 인자의 수
- 남는 인자에 대해서는 처리할 매개변수가 없기 때문에 무시됨

```js
function add(x, y) {
  return x + y;
}
console.log(add(3, 4, 5)); // 7
```

#### 💻 [02-13 매개변수와 인자의 수](../workspace-ins/ch02/ex02-13.js)

---

## 6. 암묵적 매개변수

### 6.1 암묵적 매개변수
- 모든 함수에서 명시적으로 선언하지 않고 암묵적으로 사용할 수 있는 매개변수
- `arguments`, `this`

### 6.2 arguments
- 참고: https://ko.javascript.info/rest-parameters-spread#ref-545

- 함수 내에서 `arguments` 변수로 접근 가능
- 함수에 전달된 모든 인자들을 담고 있는 컬렉션(유사 배열 객체)
- 배열과 비슷하게 `length` 속성과 index로 각 인자에 접근 가능
- `arguments` 대신 ES6의 "나머지 매개변수 (...)" 사용을 권장

#### 💻 [02-13-02 arguments](../workspace-ins/ch02/ex02-13-02.js)
#### 💻 [02-13-03 arguments 대신 나머지 매개변수 사용](../workspace-ins/ch02/ex02-13-03.js)

### 6.3 this
- 함수 내에서 `this` 키워드로 접근 가능
- "함수 컨텍스트" 객체
- 함수를 호출한 객체에 대한 참조

---

## 7. 함수 호출 방법

### 7.1 함수 호출 방법 1 - 일반 함수로 호출
- 참고: https://ko.javascript.info/function-basics#ref-15

- 일반적인 함수 호출 방법
- `함수명()`
- `this`는 `window` 객체(module 방식에서 this는 undefined가 됨)
  + `window` 객체는 어디서나 참조 가능하므로 `this`를 사용할 필요 없음

```js
function f1(){
  console.log(this);
  window.console.log('hi');
  console.log('window 생략');
  this.console.log('hello');
};
f1();

const f2 = function(){
  console.log(this);
};
f2();
```

#### 💻 [02-14 함수 호출 방법 1 - 일반 함수](../workspace-ins/ch02/ex02-14.js)

### 7.2 함수 호출 방법 2 - 메서드로 호출
- 참고: https://ko.javascript.info/object-methods

- 객체에 정의된 메서드를 호출할 때
- `객체.메서드명()`
- `this`는 메서드를 정의한 객체
  + `this`는 생성된 객체를 참조하므로 객체에 종속적인 속성을 부여하는게 가능
  + 함수를 하나만 정의하고 여러 객체에서 메서드로 사용
  + 자바스크립트로 객체지향 프로그래밍을 가능하게 하는 중요한 특징

```js
const getPingName = function() {
  return this.pingName;
};

const baro = { 
  pingName: '바로핑', 
  age: 11, 
  getName: getPingName 
};
const rara = { 
  pingName: '라라핑', 
  age: 9, 
  getName: getPingName 
};

console.log(baro.age, baro.getName()); // 11 '바로핑'

console.log(rara.age, rara.getName()); // 9 '라라핑'
```

#### 💻 [02-15 함수 호출 방법 2 - 메서드](../workspace-ins/ch02/ex02-15.js)
#### 💻 [02-01-02 변수, 배열 엘리먼트, 다른 객체의 프로퍼티에 함수 할당 - this 출력](../workspace-ins/ch02/ex02-01-02.js)
#### 💻 [01-28-02 유사 배열 객체 - this 사용](../workspace-ins/ch01/ex01-28-02.js)

#### 화살표 함수로 메서드 호출
- 일반 함수나 메서드와 동일하게 호출하지만 함수 내부에 `arguments`나 `this`가 생성되지 않고 상위 컨텍스트의 `arguments`, `this`를 사용하게 됨

```js
const getPingName = () => {
  return this.pingName;
};

const baro = { 
  pingName: '바로핑', 
  age: 11, 
  getName: getPingName 
};
const rara = { 
  pingName: '라라핑', 
  age: 9, 
  getName: getPingName 
};

console.log(baro.age, baro.getName()); // 11 undefined

console.log(rara.age, rara.getName()); // 9 undefined
```

#### 💻 [02-16 함수 호출 방법 2 - 메서드(화살표 함수)](../workspace-ins/ch02/ex02-16.js)

### 7.3 함수 호출 방법 3 - apply(), call()로 호출
- 참고: https://ko.javascript.info/call-apply-decorators

- 함수에 정의된 메서드
- `함수명.apply()`, `함수명.call()` 형태로 호출
- `this`는 `apply()`, `call()` 메서드의 첫번째 인자로 전달되는 객체
- `this`를 명시적으로 지정할 수 있음

#### apply(p1, p2) 메서드
- 두 개의 매개변수를 가짐
- 첫 번째 매개변수(p1)에는 `this`로 사용할 객체를 전달
- 두 번째 매개변수(p2)에는 함수에 전달할 인자값 배열을 지정

#### call(p1, p2, p3, …) 메서드
- 여러 개의 매개변수를 가짐
- 첫 번째 매개변수(p1)에는 `this`로 사용할 객체를 전달
- 두 번째 이후의 매개변수(p2, p3, …)에는 함수에 전달할 인자값을 차례대로 지정

#### 💻 [02-05-02 선언문 - call, apply 추가](../workspace-ins/ch02/ex02-05-02.js)
#### 💻 [02-15-02 함수 호출 방법 2 - 메서드 - call, apply 추가](../workspace-ins/ch02/ex02-15-02.js)
#### 💻 [02-17 함수 내부의 this 바인딩 문제](../workspace-ins/ch02/ex02-17.js)
#### 💻 [02-17-02 함수 내부의 this 바인딩 문제 해결 - 변수에 this 할당](../workspace-ins/ch02/ex02-17-02.js)
#### 💻 [02-17-03 함수 내부의 this 바인딩 문제 해결 - call](../workspace-ins/ch02/ex02-17-03.js)
#### 💻 [02-17-04 함수 내부의 this 바인딩 문제 해결 - 화살표 함수](../workspace-ins/ch02/ex02-17-04.js)

#### 배열의 push() 메서드 기능
- 배열의 마지막에 지정한 요소를 추가한다.
- `this`로 지정된 Array 객체의 `length` 속성값에 해당하는 속성을 만들고 지정한 요소를 저장한 후 `length`를 하나 증가시킨다.

#### Array의 push() 메서드를 이용하여 객체를 배열처럼 동작시키기
- `length` 속성 추가
- `Array.prototype.push.call(객체, 추가할 요소)`

#### prototype
- 생성자 함수를 통해 생성되는 객체의 메서드를 정의하는 속성
- 모든 함수에 자동으로 할당됨

#### 💻 [01-28-03 유사 배열 객체 - Array.prototype 사용](../workspace-ins/ch01/ex01-28-03.js)

#### apply() 활용
- 배열 데이터를 각각의 매개변수로 분리하여 전달할 때

```js
Math.min(n1, n2, n3, ...); // Math.min()은 여러 인자값을 받아서 최소값을 반환함
Math.max(n1, n2, n3, ...); // Math.min()은 여러 인자값을 받아서 최대값을 반환함

const a = [e1, e2, e2, ...];
Math.min(a[0], a[1], a[2], ...???); // 배열을 전달할 수 없으므로 배열의 각 요소를 전달해야 하지만 배열의 개수를 알 수 없는 경우에는???

Math.min.apply(Math, a); // apply를 활용해서 배열을 전달할 수 있음
```

#### 💻 [02-18 가변 인자 처리 - apply() 활용](../workspace-ins/ch02/ex02-18.js)

#### 전개 구문 활용(ECMAScript 6)
```js
Math.min(...a);
```

#### 💻 [02-18-02 가변 인자 처리 - 전개 구문 활용](../workspace-ins/ch02/ex02-18-02.js)

### 7.4 함수 호출 방법 4 - 생성자 함수로 호출
- 참고: https://ko.javascript.info/constructor-new

#### 생성자 함수
- 객체의 생성에 사용되는 함수
- `new 함수명()`
- `this`는 생성자를 통해 생성된 객체

#### 생성자 함수가 호출될 때의 내부 동작
- 빈 객체를 새로 생성
- 새로 생성된 객체는 `this`로 생성자 함수에 전달
- 명시적으로 반환하는 객체가 없다면 생성된 객체를 반환
  + 생성자 함수가 반환한 객체를 `인스턴스`라고 부름
- 객체지향 프로그램의 `new` 연산자와 비슷한 동작

#### 💻 [02-19 생성자 함수](../workspace-ins/ch02/ex02-19.js)
#### 💻 [02-20 생성자 함수 활용](../workspace-ins/ch02/ex02-20.js)

#### 생성자를 작성할 때 고려해야 할 것들
- 일반 함수처럼 호출할 수 있지만 이럴 경우 생성자 내부의 `this`는 `window` 객체를 가리키므로 객체에 종속적인 값을 지정할 수 없으므로 의미가 없다.
- 명명(naming) 규칙
  + 일반 함수: 작업할 동작을 나타내는 동사로 이름 짓고 소문자로 시작
  + 생성자: 생성할 객체를 나타내는 명사로 이름 짓고 대문자로 시작

#### 자바스크립트의 생성자 함수들

```js
// Number 생성자
const age = new Number(30);
// 대신
const age = 30;

// String 생성자
const name = new String('문자핑');
// 대신
const name = '문자핑';

// Boolean 생성자
const member = new Boolean(true);
// 대신
const member = true;

// Object 생성자
const obj = new Object();
// 대신
const obj = {};

// Array 생성자
const arr = new Array();
// 대신
const arr = [];

// Function 생성자
const f = new Function('x', 'y', 'return x + y;');
// 대신
const f = (x, y) => { 
  return x + y; 
}
const f = (x, y) => x + y;

// Date 생성자
const date = new Date();
```

---

## 8. 익명 함수 (Anonymous function)

### 8.1 익명 함수의 사용처
- 함수의 이름 대신 변수명, 속성명으로 사용할 경우
  + 함수를 변수에 저장
  + 객체의 메서드로 지정
- 함수를 인자값으로 전달할 경우
  + 전달한 인자값은 호출되는 함수 내부에서 적절한 매개변수를 지정해서 사용

```js
const f1 = function(){};
const obj = {
  f2: function(){}
};
window.onload = function(){};
setTimeout(function(){}, 1000);
```

```js
const f1 = () => {};
const obj = {
  f2: () => {}
};
window.onload = () => {};
setTimeout(() => {}, 1000);
```

---

## 9. 콜백 함수 (Callback function)
- 참고: https://ko.javascript.info/function-expressions#ref-228

### 9.1 콜백 함수
- 다른 함수에 인자로 전달되어 어떤 작업의 결과로 호출되는 함수
- 특정한 상황이 되거나(이벤트 발생) 지정한 시간이 흐르면(timeout) 또는 특정 작업의 수행이 끝나면 호출하도록 지정한 함수

```js
setTimeout(() => {
  console.log('1초가 흐름');
}, 1000);

btn.addEventListener('click', () => {
  console.log('버튼 클릭');
});

function sendData(data, cb) {
  // data를 서버에 전송한다.
  // ......
  cb();
}

const newPing = { 
  name: '새로핑', 
  age: 7 
};
sendData(newPing, () => {
  console.log('회원 가입 완료'); // sendData 함수의 작업 완료 후에 호출
});

const newPost = {
  title: '콜백 함수란', 
  writer: '진지핑'
};
sendData(newPost, () => {
  console.log('게시글 작성 완료'); // sendData 함수의 작업 완료 후에 호출
});
```

#### 💻 [02-21 익명함수와 콜백함수](../workspace-ins/ch02/ex02-21.html)

---

## 10. 순수 함수 (Pure Function)

### 10.1 순수 함수
- 동일한 입력값에 대해서 항상 동일한 출력을 하는 함수
- 외부값에 영향을 주거나 받지 않는 함수
- Side Effect가 없는 함수
- Side Effect란?
  + 함수가 자기 외부 상태를 변경하는 행위(함수 외부의 변수를 수정)

```js
let sum = 0;
function add(a, b) { // 순수 함수 X
  sum = a + b; // 외부 상태를 변경(Side Effect 발생)
}
console.log(sum); // 0
add(10, 20);
console.log(sum); // 30
```

```js
let sum = 0;
function add(a, b) { // 순수 함수 X
  return sum + a + b; // 외부 상태에 의존
}
console.log(add(10, 20)); // 30
sum = 100;
console.log(add(10, 20)); // 130
```

```js
let sum = 0;
function add(a, b) { // 순수 함수 O
  return a + b; // 외부값에 영향을 주거나 받지 않음
}
console.log(add(10, 20)); // 30
sum = 100;
console.log(add(10, 20)); // 30
```

### 10.2 순수 함수의 장점
1. 예측 가능성: 입력이 같으면 항상 결과가 같으므로 결과 예측 가능
2. 테스트 용이성: 외부 의존이 없어서 단위 테스트 간단. 디버깅이 쉽고 버그가 줄어듬
3. 재사용성: Side Effect가 없어서 다양한 상황에서 안전하게 재사용 가능
4. 함수형 프로그래밍에 적합: map, filter, reduce 같은 고차 함수와 결합하기 좋음
5. 불변성 유지: 데이터 변경이 일어나지 않아 예기치 못한 상태 변화를 막음
- 코드의 안정성과 유지보수성을 높임

---

## 11. 고차 함수 (Higher-Order Function)

### 11.1 고차 함수
- 함수를 인자로 받거나 반환하는 함수
- 함수를 일급 객체로 다루어 동적으로 로직을 구성할 수 있음

#### 고차함수의 장점
1. 코드 재사용성: 동일한 구조의 로직에 다른 함수를 전달하여 다양한 용도로 활용
2. 유연성: 함수를 인자로 받아 런타임에 다른 동작을 수행할 수 있음
3. 조합성: 함수들을 조합하여 복잡한 로직을 구성 가능
4. 확장성: 새로운 동작을 함수로 전달하여 기존 코드 수정 없이 기능 확장

### 11.2 배열 고차 함수(함수를 인자로 받음)
- `sort()`, `forEach()`, `map()`, `filter()`, `reduce()`, `some()`, `every()`, `find()`, `findIndex()`

#### 💻 [02-22 배열 다루기 - for 문 사용](../workspace-ins/ch02/ex02-22.js)
#### 💻 [02-22-02 배열 다루기 - 배열 메서드 forEach(고차함수) 사용](../workspace-ins/ch02/ex02-22-02.js)
#### 💻 [02-22-03 배열 다루기 - 배열의 다양한 메서드(고차함수) 사용](../workspace-ins/ch02/ex02-22-03.js)

### 11.3 Currying(함수를 반환)
- Closure 단원에서 확인

### 11.4 Partial application(함수를 인자로 받고 함수를 반환)
- Closure 단원에서 확인

---

## 12. 고차 함수 사용 예 - 메모이제이션

### 12.1 Memoization
- 이전의 계산 결과를 기억하는 기능을 갖춘 함수
- 함수는 객체이기 때문에 함수의 속성값으로 계산 결과 캐시
- 함수에 종속된 속성을 이용하기 때문에 외부에 노출하지 않고 함수 자체적으로 구현 가능

### 12.2 장점
- 이미 수행한 복잡한 연산을 반복하지 않도록 함으로서 성능을 향상
- 사용자가 알 수 없게 내부적으로만 동작

### 12.3 단점
- 캐시에 필요한 메모리 사용량 증가
- 비즈니스 로직과 캐싱 기능의 혼재
- 부하 테스트(Load test)나 알고리즘의 성능 테스트가 어려워짐

#### 💻 [02-23 소수 판별](../workspace-ins/ch02/ex02-23.js)
#### 💻 [02-23-02 소수 판별 - 메모이제이션](../workspace-ins/ch02/ex02-23-02.js)

---

## 13. 즉시 실행 함수

### 13.1 즉시 실행 함수(Immediately-Invoked Function Expression)
- 함수를 정의하는 동시에 즉시 실행하는 패턴

#### 기본 문법

- 일반 코드 (즉시 실행)
  ```js
  const msg = "함수 호출";
  console.log(msg); // 출력: 함수 호출
  ```

- 함수 선언 (실행되지 않음)
  ```js
  function(){
    const msg = "함수 호출";
    console.log(msg);
  }
  ```

- 즉시 실행 함수
  ```js
  (function(){
    const msg = "함수 호출";
    console.log(msg); // 출력: 함수 호출
  })();
  ```

#### 코드 실행 순서
1. 함수 객체 생성: 괄호 안의 함수 표현식이 평가되어 함수 객체가 생성됨
2. 함수 즉시 실행: 생성된 함수 객체가 바로 `()`에 의해 호출되어 실행됨
3. 함수 실행 완료: 함수 실행이 끝나면 함수에 이름이 없어서 더 이상 참조할 수 없음

#### 특징
- 익명 함수이므로 실행 후에는 접근할 방법이 없음
- 전역 스코프를 오염시키지 않음
- 일회성 실행이 필요한 코드에 적합

#### 일반 함수와 즉시 실행 함수 비교

- 실행할 코드
  ```js
  var alert = '경고 메시지!!!';
  console.log(alert); // 출력: 경고 메시지!!!
  ```

- 일반 함수
  ```js
  var f = function(){
    const msg = '경고 메시지!!!';
    console.log(msg); // 출력: 경고 메시지!!!
  };
  f();
  ```

- 일반 함수(매개변수가 있는 경우)
  ```js
  var f = function(msg){
    console.log(msg); // 출력: 경고 메시지!!!
  };
  f('경고 메시지!!!');
  ```

- 즉시 실행 함수
  ```js
  (function(){
    var msg = '경고 메시지!!!';
    console.log(msg); // 출력: 경고 메시지!!!
  })();
  ```

- 즉시 실행 함수(매개변수가 있는 경우)
  ```js
  (function(msg){
    console.log(msg); // 출력: 경고 메시지!!!
  })('경고 메시지!!!');
  ```

#### 💻 [02-24 즉시실행 함수](../workspace-ins/ch02/ex02-24.js)

---

### 13.2 즉시 실행 함수 용법

#### 임시 유효 범위와 private 변수
- 코드를 함수로 감싸고 호출하면 해당 코드의 유효 범위가 함수로 제한
- 함수 내에서 선언한 변수는 지역변수이므로 외부에 노출되지 않아서 외부 변수와 충돌이 발생하지 않음
- 즉, 외부에서 접근할 수 없는 독립적인 공간을 확보할 수 있음
- 특정 코드 블럭을 독립적인 모듈로 사용할 수 있음

```js
let sum = 0;
for(let i=1; i<=10; i+=2){
  sum += i;
}
console.log('1 ~ 10까지 홀수 합계', sum); // 25
```

```js
let sum = 0;
for(let i=2; i<=10; i+=2){
  sum += i;
}
console.log('1 ~ 10까지 짝수 합계', sum); // 30
```

```js
let sum = 0; // SyntaxError: Identifier 'sum' has already been declared
for(let i=1; i<=10; i+=2){
  sum += i;
}
console.log('1 ~ 10까지 홀수 합계', sum);

let sum = 0; // SyntaxError: Identifier 'sum' has already been declared
for(let i=2; i<=10; i+=2){
  sum += i;
}
console.log('1 ~ 10까지 짝수 합계', sum);
```

```js
let sum = 0;
for(let i=1; i<=10; i+=2){
  sum += i;
}
console.log('1 ~ 10까지 홀수 합계', sum); // 25

(function(){
  let sum = 0;
  for(let i=2; i<=10; i+=2){
    sum += i;
  }
  console.log('1 ~ 10까지 짝수 합계', sum); // 30
})();
```

#### 💻 [02-25 즉시실행 함수 - 임시 유효 범위](../workspace-ins/ch02/ex02-25.js)

#### 반복문에서의 블록 스코프 문제 해결
- 반복문에서 변수 스코프 문제를 해결하기 위해 IIFE 사용
- 각 반복마다 독립적인 스코프를 생성하여 변수 값이 올바르게 유지됨

```html
<button>버튼1</button>
<button>버튼2</button>
<button>버튼3</button>
<script>
  const buttons = document.querySelectorAll('button');
  
  for(var i = 0; i < buttons.length; i++) {
    const btn = buttons[i];
    btn.addEventListener('click', function() {
      console.log(`${buttons.length}개의 버튼중 ${i + 1} 클릭`);
    });
  }
  
</script>
```

#### 💻 [02-26 즉시실행 함수 - 반복문에서 사용](../workspace-ins/ch02/ex02-26.js)

---