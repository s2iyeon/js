# 클로저

## 목표
클로저 학습

## 목차
- [1. 클로저란?](#1-클로저란)
- [2. 클로저 용법](#2-클로저-용법)
  - [2.1 캡슐화](#21-캡슐화)
  - [2.2 콜백과 타이머](#22-콜백과-타이머)
  - [2.3 커링](#23-커링)
  - [2.4 Partial application](#24-partial-application)
  - [2.5 메모이제이션](#25-메모이제이션)

---

## 1. 클로저란?
- 참고: https://ko.javascript.info/closure

### 1.1 클로저란?
- 외부 함수의 지역변수를 외부 함수의 실행이 완료된 후에도 내부 함수에서 사용 가능한 현상이나 그 내부 함수
- 함수가 생성되는 시점을 기준으로 접근 가능한 변수는, 그 유효범위가 사라진 후에도 접근 가능해야 한다는 자바스크립트의 규칙을 지키기 위해 사용되는 내부 매커니즘
- 클로저로 인해 유효 범위가 사라진 변수와 함수를 접근할 수 있음

```js
function outerFn(){
  const innerVal = 'outer의 지역변수';
  const innerFn = () => {
    console.log(innerVal); // 출력: outer의 지역변수
  }
  return innerFn;
}

const closureFn = outerFn();
closureFn();
```

#### 💻 [04-01 클로저를 사용하는 예제](../workspace-ins/ch04/ex04-01.js)

### 1.2 클로저가 만들어지는 조건
1. 함수 내부에서 함수를 생성(중첩함수, 내부함수)
2. 내부함수가 외부함수의 지역변수를 참조

---

## 2. 클로저 용법

### 2.1 캡슐화

#### 캡슐화란?
- 객체 내부에서만 접근 가능한 속성을 만들어 사용하고 외부에서는 해당 속성을 직접 접근하지 못하도록 만드는 객체지향 언어의 특징
- 함수 내부에서 선언한 지역변수는 외부에서 접근하지 못하는 반면 내부 함수인 클로저에서는 접근 가능하다는 특징을 이용해서 구현
- C++, Java에서는 private 키워드로 지정 가능
- ES2019에서 class 정의시 속성명이나 메서드명 앞에 #을 붙이면 해당 class 내부에서만 접근 가능한 private 속성과 메서드 정의 기능이 추가됨

#### 캡슐화가 필요한 경우
- count의 증가는 ride 메서드를 통해서만 가능하게 하고 싶지만 외부에서 count 속성 직접 접근 가능
  ```js
  function Counter(){
    this.count = 0;

    this.ride = function(){
      this.count++;
    };

    this.getCount = function(){
      return this.count;
    };
  }
  var c = new Counter();
  c.ride();
  c.ride();
  c.count += 100;
  console.log(c.getCount()); // 102
  ```

- 외부에서 count 속성 접근 불가능
  ```js
  function Counter(){
    let count = 0;  // private 변수
    
    this.ride = function(){
      count++;      // 클로저를 통해 접근
    };
    
    this.getCount = function(){
      return count; // 클로저를 통해 접근
    };
  }

  const c = new Counter();
  c.ride();
  c.ride();
  c.count += 100;  // 직접 접근 불가능
  console.log(c.getCount()); // 2
  ```

#### 💻 [04-02 클로저를 활용한 private 변수](../workspace-ins/ch04/ex04-02.js)

---

### 2.2 콜백과 타이머

#### 콜백과 타이머에서의 클로저
- 지정된 함수들이 임의의 시간 뒤에 비동기적으로 호출이 될 때 함수 외부의 데이터에 접근해야 할 필요가 있는 경우

```js
function setTimer(){
  const outer = 100;
  setTimeout(() => {
    console.log(outer);  // 출력: 100(클로저를 통해 외부 변수 접근이 가능)
  }, 1000);
}

setTimer();
```

---

### 2.3 커링
- 참고: https://ko.javascript.info/currying-partials

#### 커링(Currying)이란?
- 여러개의 인자를 받는 함수를 단일 인자를 받는 함수의 체인으로 호출하도록 바꾸는 함수형 프로그래밍 기법 중 하나
- `sum(x, y)` → `sum(x)(y)`
- 함수형 프로그래밍 언어에 많은 공헌을 한 미국의 수학자, 논리학자인 하스켈 커리의 이름에서 따옴
- 함수의 가독성, 재사용이 좋아짐
- 마지막 인자가 입력될 때까지 함수의 실행 타이밍을 조절할 수 있음

#### 커링 예제

```js
function sum(a, b, c){
  return a + b + c;
}

const sum2 = function(a){
  return function(b){
    return function(c){
      return a + b + c;
    }
  };
};

const sum3 = (a) => (b) => (c) => a + b + c;

console.log(sum(10, 20, 30)); // 60
console.log(sum2(10)(20)(30)); // 60
console.log(sum3(10)(20)(30)); // 60
```

#### 💻 [04-03 커링](../workspace-ins/ch04/ex04-03.js)

#### lodash의 _.curry() 함수
- lodash란
  + https://lodash.com
  + 자바스크립트 유틸리티 라이브러리
  + 배열, 객체, 함수, 문자열 등 내장 객체를 간결하게 조작할 수 있도록 도와줌
  + 코드 가독성, 유지보수성 향상
- _.curry() 함수
  + https://lodash.com/docs/#curry
  + 지정한 함수에 커링 기능을 추가하는 함수

#### 💻 [04-03-02 커링 - 배열의 요소에서 찾기](../workspace-ins/ch04/ex04-03-02.js)
---

### 2.4 Partial application
- 참고: https://ko.javascript.info/currying-partials

#### Partial application(부분 적용 함수)이란?
- 기존 함수의 매개변수 중 일부를 미리 채워둔 상태의 함수

#### Partial application 동작 방식
1. 부분 적용: 기존 함수에 일부 매개변수를 미리 전달하여 새로운 함수 생성
2. 클로저 저장: 전달받은 매개변수들을 클로저 스코프에 저장
3. 함수 반환: 남은 매개변수를 받을 수 있는 새로운 함수 반환
4. 최종 실행: 반환된 함수 호출 시 저장된 매개변수와 새로 전달받은 매개변수를 결합하여 원본 함수 실행

```js
// 함수를 Partial application으로 만들어주는 partial 메서드를 함수에 추가
Function.prototype.partial = function(...preArgs){
  const fn = this;
  return function(...nextArgs){
    const args = [...preArgs, ...nextArgs];
    return fn(...args);
  };
};

const sum = (x, y) => {
  return x + y;
}

const sum100 = sum.partial(100); // 1단계: 100을 미리 적용한 새로운 함수 생성
console.log(sum100(200)); // 2단계: 남은 매개변수 200을 전달하여 최종 실행 (결과: 300)
```

#### 💻 [04-04 Partial application](../workspace-ins/ch04/ex04-04.js)

#### partial 메서드에 사용된 자바스크립트 개념
- `Function.prototype.partial`: [prototype](03.js_prototype.md#52-내장된-생성자-함수의-prototype)
- `(...preArgs)` `(...nextArgs)`: [나머지 매개변수](01.js_basic.md#23-es6---나머지-매개변수rest-parameters)
- `this`: [함수 호출 방법 2 - 메서드로 호출](02.js_function.md#72-함수-호출-방법-2---메서드로-호출)
- `return function(){ ... };`: [고차 함수](02.js_function.md#11-고차-함수-higher-order-function)
- `[...preArgs, ...nextArgs]` `fn(...ages)`: [전개 구문](01.js_basic.md#24-es6---전개-구문spread-syntax)
- 외부 함수 리턴 후에 `fn` `preArgs` 접근: [Closure](#11-클로저란)

#### lodash의 _.partial() 함수
- https://lodash.com/docs/#partial
- 지정한 함수에 Partial application 기능을 추가하는 함수

#### Function.prototype.bind() 메서드
- Partial application 기능을 구현한 메서드
- lodash의 _.partial() 함수와 비슷하나 미리 전달하는 인자에 this도 지정하는 기능이 추가

#### 💻 [02-17-05 함수 내부의 this 바인딩 문제 해결 - Function.prototype.bind()](../workspace-ins/ch02/ex02-17-05.js)
#### 💻 [04-04-02 Partial application - 로그 출력 함수](../workspace-ins/ch04/ex04-04-02.js)

---

### 2.5 메모이제이션

#### 메모이제이션이란?
- 함수의 결과를 캐시하여 같은 입력에 대해 다시 계산하지 않고 저장된 결과를 반환하는 최적화 기법

#### 존재하는 함수의 동작을 수정 (클로저가 필요 없음)
- 함수의 내부를 수정하지 않고 메모이제이션 기능 추가

```js
Function.prototype.memo = function(key){
  this._cache = this._cache || {};
  if(this._cache[key] !== undefined){
    return this._cache[key];
  }else{
    return this._cache[key] = this(key);
  }
};

isPrime(5); // 캐시되지 않음
isPrime.memo(1000000007); // 캐시됨
```

#### 💻 [04-05 메모이제이션](../workspace-ins/ch04/ex04-05.js)

#### 기존 함수를 래핑하여 새로운 함수 생성 (클로저 이용)

```js
Function.prototype.memoize = function(){
  const fn = this;
  return function(){
    return fn.memo.apply(fn, arguments);
  };
};

isPrime(5); // 캐시되지 않음
isPrime = isPrime.memoize();
isPrime(5); // 캐시됨
```

#### 💻 [04-06 메모이제이션, 클로저 사용](../workspace-ins/ch04/ex04-06.js)

#### memoize 메서드에 사용된 자바스크립트 개념
- `Function.prototype.memoize`: [prototype](03.js_prototype.md#52-내장된-생성자-함수의-prototype)
- `this`: [함수 호출 방법 2 - 메서드로 호출](02.js_function.md#72-함수-호출-방법-2---메서드로-호출)
- `return function(){ ... };`: [고차 함수](02.js_function.md#11-고차-함수-higher-order-function)
- `apply`: [함수 호출 방법 3 - apply(), call()로 호출](02.js_function.md#73-함수-호출-방법-3---apply-call로-호출)
- `arguments`: [암묵적 매개변수 arguments](02.js_function.md#62-arguments)
- 외부 함수 리턴 후에 `fn` 접근: [Closure](#11-클로저란)

---
